{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAkBMA,EAAkB,CAACC,EAAoBC,EAChDC,EAAkCC,eAAeC,OAASD,eAAeE,YACrE,MAAMC,EAASN,EAAOO,aAAa,CAC/BC,KAAMP,EAAKQ,WACXC,MAAOR,EACPS,kBAAkB,IAItB,OAFA,IAAIC,aAAaN,EAAOO,kBAAkBC,IAAIb,GAC9CK,EAAOS,QACAT,CAAM,EAGRU,EAAU,KAAW,O,OAAD,E,OAAA,E,EAAA,Y,MAC7B,MAAMC,EA/BiB,MACvB,IAAIC,EAAS,+CAcb,OAZKC,UAAUC,MACXF,EAAS,6oBAWNA,CAAM,EAgBIG,GACjB,GAAIJ,EAASK,SAAS,iDAElB,MADAC,QAAQC,IAAIP,GACP,EAGT,MAAMQ,EAASC,SAASC,eAAe,iBACjCC,QAA6B,QAAb,EAAAT,UAAUC,WAAG,eAAES,iBAC/B7B,QAAe4B,aAAO,EAAPA,EAASE,gBACxBC,EAAUN,EAAOO,WAAW,UAC5BC,EAASd,UAAUC,IAAIc,2BAQ7B,OANAH,EAAQI,UAAU,CACdnC,OAAQA,EACRiC,OAAQA,EACRG,UAAU,WAGP,CAAEpC,SAAQyB,SAAQQ,SAAQF,UAErC,E,YArBiC,K,6QAqBhC,E,UC/CgC,YAC7B,MAAMX,QAAYJ,IACZhB,EAASoB,EAAIpB,OAEbqC,EAAa,IAAIzB,aAAa,EAC/B,IAAM,GACP,IAAM,IACL,GAAK,IACL,GAAK,GACN,IAAM,GACN,GAAK,KAGH0B,EAAY,IAAI1B,aAAa,CAC/B,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,IAGJ2B,EAAexC,EAAgBC,EAAQqC,GACvCG,EAAczC,EAAgBC,EAAQsC,GAEtCG,EC5BS,+YD4BTA,ECbW,+IDcXC,EAAW1C,EAAO2C,qBAAqB,CACzCC,OAAO,OACPC,OAAQ,CACJC,OAAQ9C,EAAO+C,mBAAmB,CAC9BC,KAAMP,IAEVQ,WAAY,OACZC,QAAS,CACL,CACIC,YAAa,EACbC,WAAY,CAAC,CACTC,eAAgB,EAChBpB,OAAQ,YACRqB,OAAQ,KAGhB,CACIH,YAAa,GACbC,WAAY,CAAC,CACTC,eAAgB,EAChBpB,OAAQ,YACRqB,OAAQ,OAKxBC,SAAU,CACNT,OAAQ9C,EAAO+C,mBAAmB,CAC9BC,KAAMP,IAEVQ,WAAY,OACZO,QAAS,CAAC,CACNvB,OAAQb,EAAIa,UAGpBwB,UAAU,CACPC,SAAU,mBAIXC,EAAiB3D,EAAO4D,uBACxBC,EAAczC,EAAIW,QAAQ+B,oBAAoBC,aAC9CC,EAAaL,EAAeM,gBAAgB,CAC9CC,iBAAkB,CAAC,CACfC,KAAMN,EACNO,WAAY,CAAEC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GACzCC,OAAQ,QACRC,QAAS,YAGjBV,EAAWW,gBAAgB,EAAGpC,GAC9ByB,EAAWW,gBAAgB,EAAGnC,GAC9BwB,EAAWY,YAAYlC,GACvBsB,EAAWa,KAAK,GAChBb,EAAWc,MAEX9E,EAAO+E,MAAMC,OAAO,CAACrB,EAAesB,UACxC,E,YAnFiC,K,kPAAA,E","sources":["webpack://gpu001/./src/helper.ts","webpack://gpu001/./src/main.ts","webpack://gpu001/./src/shaders.ts"],"sourcesContent":["export const CheckWebGPU = () => {\n    let result = \"Great, your current browser supports WebGPU!\";\n\n    if (!navigator.gpu) {\n        result = `Your current browser does not support WebGPU! Make sure you are on a system \n        with WebGPU enabled. Currently, WebGPU is supported in  \n        <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\n        with the flag \"enable-unsafe-webgpu\" enabled. See the \n        <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\"> \n        Implementation Status</a> page for more details.   \n        You can also use your regular Chrome to try a pre-release version of WebGPU via\n        <a href=\"https://developer.chrome.com/origintrials/#/view_trial/118219490218475521\">Origin Trial</a>.                \n        `;\n    } \n\n    return result;\n}\n\nexport const CreateGPUBuffer = (device : GPUDevice, data:Float32Array,\n    usageFlag : GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST) => {\n        const buffer = device.createBuffer({\n            size: data.byteLength,\n            usage: usageFlag,\n            mappedAtCreation: true\n        });\n        new Float32Array(buffer.getMappedRange()).set(data);\n        buffer.unmap();\n        return buffer;\n    }\n\nexport const InitGPU = async() => {\n    const checkgpu = CheckWebGPU();\n    if (checkgpu.includes(\"Your current browser does not support WebGPU!\")) {\n        console.log(checkgpu);\n        throw(checkgpu);\n    }\n\n    const canvas = document.getElementById('canvas-webgpu') as HTMLCanvasElement;\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter?.requestDevice() as GPUDevice;\n    const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n    const format = navigator.gpu.getPreferredCanvasFormat();\n\n    context.configure({\n        device: device,\n        format: format,\n        alphaMode:'opaque'\n    });\n\n    return { device, canvas, format, context };\n    \n}","import $ from 'jquery';\nimport { InitGPU, CreateGPUBuffer } from './helper';\nimport { Shaders } from './shaders';\n\nconst CreateSquare = async () => {\n    const gpu = await InitGPU();\n    const device = gpu.device;\n\n    const vertexData = new Float32Array([\n        -0.5, -0.5,\n        0.5, -0.5,\n        -0.5, 0.5,\n        -0.5, 0.5,\n        0.5, -0.5,\n        0.5, 0.5,\n    ]);\n\n    const colorData = new Float32Array([\n        1, 0, 0,\n        0, 1, 0,\n        1, 1, 0,\n        1, 1, 0,\n        0, 1, 0,\n        0, 0, 1,\n    ]);\n\n    const vertexBuffer = CreateGPUBuffer(device, vertexData);\n    const colorBuffer = CreateGPUBuffer(device, colorData);\n    \n    const shader = Shaders();\n    const pipeline = device.createRenderPipeline({\n        layout:'auto',\n        vertex: {\n            module: device.createShaderModule({                    \n                code: shader.vertex,\n            }),\n            entryPoint: \"main\",\n            buffers: [\n                {\n                    arrayStride: 8,\n                    attributes: [{\n                        shaderLocation: 0,\n                        format: \"float32x2\",\n                        offset: 0\n                    }]\n                },\n                {\n                    arrayStride: 12,\n                    attributes: [{\n                        shaderLocation: 1,\n                        format: \"float32x3\",\n                        offset: 0\n                    }]\n                }\n            ]\n        },\n        fragment: {\n            module: device.createShaderModule({                    \n                code: shader.fragment,\n            }),\n            entryPoint: \"main\",\n            targets: [{\n                format: gpu.format as GPUTextureFormat\n            }]\n         },\n        primitive:{\n           topology: \"triangle-list\", \n        }\n    });\n\n    const commandEncoder = device.createCommandEncoder();\n    const textureView = gpu.context.getCurrentTexture().createView();\n    const renderPass = commandEncoder.beginRenderPass({\n        colorAttachments: [{\n            view: textureView,\n            clearValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 }, //background color\n            loadOp: 'clear',\n            storeOp: 'store'\n        }]\n    });\n    renderPass.setVertexBuffer(0, vertexBuffer);\n    renderPass.setVertexBuffer(1, colorBuffer);\n    renderPass.setPipeline(pipeline);\n    renderPass.draw(6);\n    renderPass.end();\n\n    device.queue.submit([commandEncoder.finish()]);\n}\n\nCreateSquare();","export const Shaders = () => {\n    const vertex = `\n        struct Output {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) vColor : vec4<f32>,\n        };\n\n        @vertex\n        fn main(@location(0) pos: vec4<f32>, @location(1) color: vec4<f32>) -> Output {\n            var output: Output;\n            output.Position = pos;\n            output.vColor = color;\n            return output;\n        } \n    `;\n\n    const fragment = `\n        @fragment\n        fn main(@location(0) vColor: vec4<f32>)-> @location(0) vec4<f32> {\n            return vColor;\n        }\n    `;\n    return {vertex, fragment};\n}"],"names":["CreateGPUBuffer","device","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","size","byteLength","usage","mappedAtCreation","Float32Array","getMappedRange","set","unmap","InitGPU","checkgpu","result","navigator","gpu","CheckWebGPU","includes","console","log","canvas","document","getElementById","adapter","requestAdapter","requestDevice","context","getContext","format","getPreferredCanvasFormat","configure","alphaMode","vertexData","colorData","vertexBuffer","colorBuffer","shader","pipeline","createRenderPipeline","layout","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","commandEncoder","createCommandEncoder","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","setVertexBuffer","setPipeline","draw","end","queue","submit","finish"],"sourceRoot":""}